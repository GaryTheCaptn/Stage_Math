from random import randint
from scipy.integrate import quad
import scipy.stats
import numpy
import numpy as np
from matplotlib import pyplot as plt


def quicksort(l: list[int]) -> list[int]:
    """
    :param l: une liste d'entiers non triée
    :return: la liste l triée selon l'algorithme quicksort
    """
    if (len(l) == 0):
        return []
    else:
        ind = int(len(l) / 2)
        pivot = l[ind]
        left = []
        right = []
        l.pop(ind)
        for x in l:
            if (x <= pivot):
                left = left + [x]
            else:
                right = right + [x]
        return quicksort(left) + [pivot] + quicksort(right)


def counter(l: list[int]) -> (list[int], int):
    """
    :param l: une liste d'entiers
    :return: le tuple compose de la liste l triee et du nombre
    total d'éléments qui apparaissent plus de deux fois.
    """
    res : list[int,int] = []
    count : int = 0
    while (len(l) > 0):
        temp = retire(l, l[0])
        res = res + [temp]

    for i in range(len(res)):
        if (res[i][1] > 1):
            count = count + res[i][1]
    return quicksort(res), count


def retire(l: list[int], e: int) -> (int, int):
    """
    Enleve toutes les occurrences de e dans la liste l
    :param l: une liste d'entiers
    :param e: un entier
    :return: le tuple (elt, nbOccurrences)
    """
    count = 0
    for x in l:
        if x == e:
            count += 1
    for i in range(count):
        l.remove(e)
    return (e,count)


def anniversaire(n: int) -> (list[int], int):
    """
    :param n: Le nombre d'eleves dans la classe
    :return: la liste des (jour, nombre d'anniversaires en ce jour).
    """
    personnes = []
    for j in range(n):
        personnes.append(randint(1, 365))
    return counter(personnes)

def maxanniv(l: list[(int, int)])-> int:
    """
    :param l: une répartition d'anniversaires en (jour, nombre d'anniversaires en ce jour)
    :return: le plus grand nombre d'anniversaires le même jour de la liste
    """
    max = l[0][1]
    for i in range(len(l)):
        if (l[i][1] > max):
            max = l[i][1]
    return max


def affichageAnniv(n: int):
    """ Affiche un graphique représentatif de la repartition des dates de
    naissances des n eleves sur les 365 jours de l'annee.
    :param n: le nombre d'élèves dans une classe
    """
    donnees: list[(int, int)] = anniversaire(n)[0]  # la liste des (jours, nbAnniv)
    max: int = maxanniv(donnees)  # Le plus grand nombre d'anniversaires en un jour
    # make data:
    y: list[(int, int)] = []
    x: list[(int, int)] = []
    for k in range(len(donnees)):  # On récupère les premières et secondes composantes
        x = x + [donnees[k][0]]  # des (jours,nbAnniv)
        y = y + [donnees[k][1]]
    # plot
    fig, ax = plt.subplots()
    ax.bar(x, y, width=1, edgecolor="white", linewidth=0.7)
    ax.set(yticks=np.arange(0, max + 1))
    plt.xlabel("Nombre d'élèves nés le même jour")
    plt.ylabel("Jours de l'année")
    plt.title(f"Graphe représentatif d'une répartition de {n} élèves sur 365 jours.")
    plt.show()


def moyenne(l: list[(int)]) -> float:
    """
    :param l: une liste d'entiers
    :return: la moyenne arithmetique arrondie à 2 décimales de la liste l
    """
    res = 0
    for x in l:
        res = res + x
    return round((res / len(l)), 2)


def genMoyennes(n: int) -> list[float]:  # nommons "set" le jeu des 366 répartitions obtenues
    # en faisant varier le nombre d'élèves entre 1 et 366
    """
    :param n: le nombre de sets différents générés
    :return: la liste de la moyenne du nombre maximum de personnes nées un jour
    """
    n_set=[] #Tableau 2D des sets
    res=[]
    #Génération du n_set
    for j in range(n):
        #Génération d'un set
        set = []
        for i in range(1, 367):
            set.append(anniversaire(i)[1]) #On ajoute le nombre total d'élèves nés le même jour
        n_set.append(set)
    #Moyenne des n_sets par colonnes
    for i in range(366):
        temp = 0
        for j in range(n):
            temp += n_set[j][i] #Somme de la colonne pour j entre 1 et n
        res.append(round(temp/n,2)) #Ajoute la moyenne de chaque colonne à res
    return res

def afficheAnniversaire2(n: int):
    """
    Affiche le nombre d'eleves nes le meme jour pour n sets de 366 repartitions
    :param n: le nombre d'élèves
    """
    y = genMoyennes(n)
    x = numpy.arange(366)
    fig, ax = plt.subplots()
    ax.bar(x, y, width=1, edgecolor="white", linewidth=0.7)
    plt.title(f"Affichage du nombre d'élèves nés le même jour en fonction du nombre d'élèves pour {n} sets.")
    plt.xlabel("Nombre d'élèves")
    plt.ylabel("Nombre total d'élèves nés le même jour")
    plt.show()


# Le jour qui a le plus d'élèves ?
# On va générer une répartition de n élèves avec n dans {1,...,365}
# On identifie le plus grand nombre d'élèves nés le même jour ( avec max )
# On stocke cette info dans une moyenne temporaire,
# on répète k fois puis on fait la moyenne réelle et on le stocke dans res

def genMoyennes2(n: int) -> list[int]:
    """
    :param n: le nombre de sets de repartitions obtenues
    en faisant varier le nombre d'élèves entre 1 et 366
    :return: la liste des moyennes du maximum d'élèves nés le même jour
    """
    # nommons "set" le jeu des 366 répartitions obtenues
    # en faisant varier le nombre d'élèves entre 1 et 366
    n_set=[] #Tableau 2D des sets
    res=[]
    #Génération du n_set
    for j in range(n):
        #Génération d'un set
        set = []
        for i in range(1, 367):
            set.append(maxanniv(anniversaire(i)[0])) #On ajoute le maximum d'élèves nés un jour
        n_set.append(set)
    #Moyenne des n_sets par colonnes
    for i in range(366):
        temp = 0
        for j in range(n):
            temp += n_set[j][i] #Somme de la colonne pour j entre 1 et n
        res.append(round(temp/n,2)) #Ajoute la moyenne de chaque colonne à res
    return res


def afficheAnniversaire3(n: int):
    """
    Affiche le nombre maximum d'élèves nés le même jour en fonction du nombre d'élèves.
    :param n: le nombre de sets de repartitions obtenues
    """
    y = genMoyennes2(n)
    x = numpy.arange(366)
    fig, ax = plt.subplots()
    ax.bar(x, y, width=1, edgecolor="white", linewidth=0.7)
    plt.title(f"Affichage du maximum d'élèves nés le même jour en fonction du nombre d'élèves pour {n} sets.")
    plt.xlabel("Nombre d'élèves")
    plt.ylabel("Maximum d'élèves nés le même jour")
    plt.show()


def max(l: list[int]):
    """
    :param l: une liste d'entiers
    :return: le plus grand élément de l
    """
    res: int = l[0]
    for i in range(len(l)):
        if l[i] > res:
            res = l[i]
    return res


def nb_oc(e: int, l: list[int]):
    """
    :param e: un entier
    :param l: une liste d'entiers
    :return: le nombre d'occurences de e dans l
    """
    res: int = 0
    for i in range(len(l)):
        if l[i] == e:
            res += 1
    return res


affichageAnniv(50)
afficheAnniversaire2(1000)
afficheAnniversaire3(1000)
